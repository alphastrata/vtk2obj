use core::panic;
use nalgebra::Point3;
use std::fs::{self, File};
use std::io::Write;
use std::io::{BufRead, BufReader};
use std::path::{Path, PathBuf};

pub struct Mesh {
    faces: Vec<Vec<u32>>,
    original_filename: PathBuf,
    verts: Vec<Point3<f32>>,
}

impl Mesh {
    // Parse a VTK file into a Mesh struct
    pub fn from_vtk_file<P: AsRef<Path>>(file_path: P) -> Result<Mesh, Box<dyn std::error::Error>> {
        let file = fs::File::open(&file_path)?;
        let reader = BufReader::new(file);

        let lines: Vec<String> = reader.lines().flatten().collect();

        // Find the start and end indices of the points section
        let start_points = lines.iter().position(|l| l.starts_with("POINTS")).unwrap();

        // Find the start and end indices of the polygons section
        let start_polys = lines
            .iter()
            .position(|l| l.starts_with("POLYGONS"))
            .unwrap();

        let sp: Vec<&str> = lines[start_polys].split_whitespace().collect();
        let end_polys = start_polys + sp[1].parse::<usize>()?;

        #[cfg(debug_assertions)]
        dbg!(&lines[start_points]);
        dbg!(&lines[start_polys]);
        dbg!(&lines[end_polys]);

        // Parse the vertices
        let verts: Vec<Point3<f32>> = lines[start_points + 1..start_polys]
            .iter()
            .flat_map(|l| {
                let parts: Vec<f32> = l
                    .split_whitespace()
                    .flat_map(|s| s.parse::<f32>())
                    .collect();

                let points: Vec<Point3<f32>> = parts
                    .chunks(3)
                    .map(|chunk| {
                        if chunk.len() == 3 {
                            Point3::new(chunk[0], chunk[1], chunk[2])
                        } else {
                            panic!("{:?}", chunk)
                        }
                    })
                    .collect();

                points
            })
            .collect();

        // Parse the faces
        let faces: Vec<Vec<u32>> = lines[start_polys + 1..end_polys]
            .iter()
            .map(|l| {
                let parts: Vec<u32> = l
                    .split_whitespace()
                    .flat_map(|s| s.parse::<u32>())
                    .collect();
                parts[1..].to_vec()
            })
            .collect();

        Ok(Mesh {
            verts,
            faces,
            original_filename: file_path.as_ref().into(),
        })
    }

    // Export the mesh as an OBJ file
    pub fn to_obj<P: AsRef<Path>>(&self, outpath: P) -> anyhow::Result<()> {
        let mut file = File::create(outpath)?;
        writeln!(file, "# OBJ file generated by vtk2obj")?;
        writeln!(file, "# from {}", self.original_filename.display())?;

        for v in self.verts.iter() {
            writeln!(file, "v {} {} {}", v[0], v[1], v[2])?;
        }

        for f in self.faces.iter() {
            writeln!(file, "f {} {} {}", f[0], f[1], f[2])?;
        }
        Ok(())
    }
}

//

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn from_vtk_file() {
        let mesh = Mesh::from_vtk_file("example.vtk").unwrap();
        assert_eq!(mesh.verts.len(), 3);
        assert_eq!(mesh.faces.len(), 1);
    }

    #[test]
    fn vtk_to_obj() {
        let mesh = Mesh::from_vtk_file("example.vtk").unwrap();
        let out_path = "example.obj";
        mesh.to_obj(out_path).unwrap();
    }
}
